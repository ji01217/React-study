# React 백그라운드 작업 & 최적화 기술

### 리액트가 실제로 작동하는 방식

#### React

- 사용자 인터페이스 구축을 위한 자바스크립트 라이브러리
- 컴포넌트를 통해 사용자 인터페이스를 효과적으로 구성하며 업데이트 또한 컴포넌트를 통해 이루어진다.
- 컴포넌트와 상태 객체를 관리하고, 다른 객체의 상태와 컴포넌트가 바뀌어야 하는지를 확인하고 컴포넌트 변경 전후의 상태를 확인하는 라이브러리이다.
- 화면에 표시되어야 할 정보 모두를 현재 사용 중인 인터페이스(리액트 DOM)에 전달한다.
- props를 관리하여 컴포넌트에 전달하는 데이터로 컴포넌트 구성을 가능하게 해주고 부모-자식 컴포넌트 간의 통신을 연결해준다.
- 컴포넌트 내부의 데이터인 state, context를 다룬다.
- props, state, context가 변경이 되면 이것들을 사용하는 컴포넌트도 리액트를 통해 변경되고, 리액트는 이 컴포넌트가 화면에 새로운 것을 표시하는지 확인한다.

#### React DOM

- 웹에 대한 인터페이스로, 실제 HTML 요소들을 화면에 표시해준다.
- 실제 DOM에 대한 작업을 하므로 사용자가 보고 있는 화면에 무언가를 표시하는 것은 리액트 DOM이 한다.

#### React & React DOM

- 리액트의 역할은 가상 DOM이라는 개념을 사용하는 것이다.
- 가상 DOM은 앱이 마지막에 만들어내는 컴포넌트 트리를 결정한다.
- 각각의 하위 트리를 갖고 있는 컴포넌트들은 JEX코드를 반환하는데 가상 DOM이 컴포넌트 트리의 현재 모양과 최종 모양을 정한다.
- state가 업데이트되면 이 정보는 리액트 DOM으로 전달되어 갱신 전후의 상태 차이를 인식하고 리액트가 컴포넌트 트리를 통해 구성한 가상 스냅샷인 가상 DOM과 일치하도록 실제 DOM을 조작하는 방법을 알 수 있게 한다.
- state나 props, contex, 컴포넌트에 변경이 발생하면 컴포넌트 함수가 재실행되어 리액트가 이를 재평가하는데 이것이 DOM을 다시 재평가하는 것은 아니다.
- 실제 DOM은 리액트가 구성한 컴포넌트의 이전 상태와 트리, 현재의 상태간의 차이점을 기반으로 변경이 필요할 때만 업데이트된다.
- 이전과 현재의 상태를 가상으로 비교하는 것은 간편하고 자원이 적게 들기 때문에 성능 측면에서 매우 중요하다.
- 리액트는 가상 DOM과의 비교를 통해 최종 스냅샷과 현재의 스냅샷을 실제 DOM에 전달하는 구조를 갖는다.
- 예를 들어 문장을 하나 추가한다고 했을 때, 리액트가 이전의 평가와 현재의 평가를 비교하여 리액트 DOM에 보고하면 리액트 DOM은 전체 DOM을 재렌더링하지 않고 새로운 문장을 집어넣는다.

### react.memo()로 불필요한 재평가 방지하기

- 부모 컴포넌트가 재평가되면 자식 컴포넌트가 변경되지 않아도 재평가되는 문제점이 있었다.
- 리액트에게 특정한 상황 예를 들면 컴포넌트가 받은 props가 변경되는 것과 같은 상황에만 자식 컴포넌트를 재실행하도록 리액트에 지시할 수 있다.

- 함수형 컴포넌트에서 props가 바뀌었는지 확인할 컴포넌트를 지정한 뒤에 react.memo()로 감싼다.

  - ```react
    export default React.memo(DemoOutput);
    ```

- React.memo는 인자로 들어간 컴포넌트에 어떤 props가 입력되는지 확인하고 입력되는 모든 props의 신규값을 확인한 뒤 기존의 props의 값과 비교하도록 리액트에게 전달한다.

- 그리고 props의 값이 바뀐 경우에만 컴포넌트를 재실행 및 재평가하게 된다.

- 부모 컴포넌트가 변경되었지만 그 컴포넌트의 props 값이 바뀌지 않았다면 컴포넌트 실행을 건너뛴다.

- 하지만 이것을 모든 컴포넌트에서 적용하지 않는 이유는 최적화에 비용이 따르기 때문이다.

  - App에 변경이 발생할 때마다 memo 메소드는 이 컴포넌트로 이동하여 기존 props 값과 새로운 값을 비교해야 하고, 그러면 리액트가 두가지 작업을 할 수 있어야 한다.
  - 기존의 props 값을 저장할 공간이 필요하고 비교하는 작업도 필요하다.
  - 컴포넌트를 재평가하는 데에 필요한 성능 비용과 props를 비교하는 성능 비용을 서로 맞바꾼다.
  - 자식 컴포넌트가 많아서 컴포넌트 트리가 매우 크다면 React.memo가 매우 유용하게 쓰일 것이다.
  - 부모 컴포넌트를 매번 재평가할 때마다 컴포넌트의 변화가 있거나 props의 값이 변화할 수 있는 경우라면 React.memo를 사용할 필요가 없을 것이다.

- 컴포넌트 트리에서 잘라낼 수 있는 몇가지의 주요 컴포넌트 부분을 선택해서 사용하는 것이 필요하다.

- Button 컴포넌트에 React.memo()를 적용했는데 바뀌는 props가 없지만 계속 재평가가 되는 것을 볼 수 있다.
  - 버튼에 전달되는 함수가 매번 재생성되기 때문이다.
  - 이전에 props로 false를 보냈을 때도 재생성이 되었지만 boolean은 자바스크립트의 원시 값이기 때문에 재평가가 되지 않았던 것이다.
  - 자바스크립트에서 `false === false`는 `true`이고, `[1, 2, 3] === [1, 2, 3]`은 `false`이다.

### useCallback()으로 함수 재생성 방지하기

#### useCallback

- 기본적으로 컴포넌트 실행 전반에 걸쳐 함수를 저장할 수 있게 하는 훅이다.

- 리액트에 이 함수를 저장하여 매번 실행할 때마다 이 함수를 재생성할 필요가 없다는 것을 알릴 수 있다.

- 선택한 함수를 리액트의 내부 저장 공간에 저장해서 함수 객체가 실행될 때마다 이것을 재사용할 수 있게 된다.

- 저장하려는 함수를 래핑하여 사용한다.

- ```react
  const toggleParagraphHandler = useCallback(() => {
      setShowParagraph((prevShowParagraph) => !prevShowParagraph);
  });
  ```

- useCallback 훅을 사용하고 함수를 첫 번째 인자로 전달하면 useCallback은 저장된 함수를 반환한다. 

- 그리고 이 App 함수가 다시 실행되면 useCallback이 리액트가 저장한 함수를 찾아서 같은 함수 객체를 재사용하게 된다.

- 어떤 함수가 절대 변경되어서는 안된다면 useCallback을 사용해 함수를 저장하면 된다.

- 두 번째 인자는 useCallback 호출에 대한 의존성 배열이다.

  - ```react
    const toggleParagraphHandler = useCallback(() => {
        setShowParagraph((prevShowParagraph) => !prevShowParagraph);
    }, []);
    ```

- 이제 Button 컴포넌트에도 React.memo()가 적용됨을 볼 수 있다.

### useCallback() 및 해당 종속성

- 자바스크립트에서 함수는 클로저이다.

- 함수가 정의될 때 자바스크립트는 함수 외부에서 사용하는 모든 변수를 잠근다.

- 토글 버튼을 활성화 시키는 버튼을 하나 더 만들어보자.

  - ```react
    const toggleParagraphHandler = useCallback(() => {
        if (allowToggle) {
            setShowParagraph((prevShowParagraph) => !prevShowParagraph);
        }
    }, []);
    ```

  - 버튼이 제대로 동작하지 않는 이유는 allowToggle이라는 변수가 App 컴포넌트가 처음 실행된 시점의 값을 저장하고 그 후로 변하지 않기 때문이다.

  - 의존성 배열에 allowToggle을 넣으면 allowToggle의 값이 바뀌면 함수를 재생성하고 새로 만든 함수를 저장하고, 변경되지 않는다면 함수 재생성을 하지 않게 된다.

### state 및 컴포넌트 자세히 살펴보기

- 리액트는 useState와 전달된 기본값에 대해서는 한 번만 고려하도록 처리한다.
- 컴포넌트가 처음 렌더링될 때  useState가 실행되면 리액트가 관리하는 새로운 상태 변수를 만든다.
- 그리고 이 변수가 어느 컴포넌트에 속하는지를 기억하고 기본값을 사용해서 상태값을 초기화 한다.
- 이후에 이 컴포넌트를 재평가하는 과정에서 useState가 호출되면 새로운 상태가 생성되는 것이 아니라 여기서 이 컴포넌트에 대한 상태가 이미 존재하는 것을 깨닫고 필요하면 상태를 업데이트한다.
- 컴포넌트가 DOM에서 완전히 삭제되지 않는 이상 상태의 초기화는 이루어지지 않는다.

### State 스케줄링 및 일괄 처리하기

- state 변경을 할 때 setNewProduct를 실행하면 state가 즉각적으로 변경되는 것은 아니다.

- setNewProduct를 호출하고 상태 업데이트 함수를 호출하면 상태 업데이트를 할 수 있도록 예약을 한다.

- 우리가 봤을 때는 작업이 바로 처리된 것처럼 느끼지만, 실제로 리액트는 이 상태 변화를 지연시킨다.

- 대다수의 성능 기반의 작업들이 거의 동시에 진행되는데 리액트는 잠재적으로 우선순위를 갖고 예정된 상태 변경을 연기할 수 있다.

- 리액트는 상태 변화가 발생하면 상태 변화의 순서를 명확히 해서 같은 타입임을 보증한다.

- 스케줄링 때문에 다수의 예약 상태 변화가 동시에 있을 수 있다. 동시에 여러 번의 갱신이 스케줄 될 수 있으므로 상태를 갱신할 때는 함수 형태로 갱신하는 것을 추천한다.

- 대부분 굉장히 빠르게 처리되기 때문에 크게 문제가 되지 않지만 이론상으로는 이 스케줄링 작업은 지연될 수 있으므로 상태 변경이 순서대로 처리되고 이전 상태를 기반으로 매 회 상태 변경이 발생할 때마다 가장 최신의 상태를 얻을 수 있게 해주는 안전한 방법이다.

- 함수 형태를 사용해야 리액트가 미완료된 상태 변경 작업에 대하여 최신의 상태를 사용하고 컴포넌트가 재렌더링 되었을 그 시점의 상태를 사용하지 않게 된다.

- ```react
  const navigateHandler = (navPath) => {
      setCurrentNavPath(navPath)
      // State was NOT updated here!
      setDrawerIsOpen(false)
  }
  ```

  - 두 개의 코드들이 같은 곳에 있고 이 둘 모두 위와 같이상태 갱신 함수를 호출한다면 리액트는 이들에 대한 상태 갱신을 하나의 동기화 프로세스에서 같이 실행한다.

### useMemo()로 최적화하기

- useMemo 훅은 useCallback이 함수에 대한 것을 저장하듯 모든 종류의 데이터를 저장할 수 있다.

- 첫 번째 인자에는 저장하고 싶은 것을 반환할 함수가 들어간다.

- 두 번재 인자에는 의존성 배열이 들어간다.

  - ```react
    const { items } = props
    
    const sortedList = useMemo(() => {
        return items.sort((a, b) => a - b)
    }, [items])
    ```

  - ```react
    const listItems = useMemo(() => [5, 3, 1, 10, 9], [])
    
    return(
      <DemoList title={listTitle} items={listItems}
    )
    ```

  - 의존성 배열을 통해 저장된 값에 변경사항이 생길 때마다 업데이트 된다.

    
